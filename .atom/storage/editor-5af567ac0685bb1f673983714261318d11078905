{"mode":"editor","version":1,"windowDimensions":{"x":253,"y":23,"width":1187,"height":800,"maximized":false},"grammars":{"deserializer":"GrammarRegistry","grammarOverridesByPath":{}},"project":{"paths":["/Users/sanoy/code/savaho/routes"],"buffers":[{"text":"// Connect to MongoDB using Mongoose\nvar mongoose = require('mongoose');\nvar db;\nif (process.env.VCAP_SERVICES) {\n   var env = JSON.parse(process.env.VCAP_SERVICES);\n   db = mongoose.createConnection(env['mongodb-2.2'][0].credentials.url);\n} else {\n   db = mongoose.createConnection('localhost', 'pollsapp');\n}\n\n// Get Poll schema and model\nvar PollSchema = require('../models/Poll.js').PollSchema;\nvar Poll = db.model('polls', PollSchema);\n\n// Main application view\nexports.index = function(req, res) {\n\tres.render('index');\n};\n\n// JSON API for list of polls\nexports.list = function(req, res) {\n\t// Query Mongo for polls, just get back the question text\n\tPoll.find({}, 'question', function(error, polls) {\n\t\tres.json(polls);\n\t});\n};\n\n// JSON API for getting a single poll\nexports.poll = function(req, res) {\n\t// Poll ID comes in the URL\n\tvar pollId = req.params.id;\n\n\t// Find the poll by its ID, use lean as we won't be changing it\n\tPoll.findById(pollId, '', { lean: true }, function(err, poll) {\n\t\tif(poll) {\n\t\t\tvar userVoted = false,\n\t\t\t\t\tuserChoice,\n\t\t\t\t\ttotalVotes = 0;\n\n\t\t\t// Loop through poll choices to determine if user has voted\n\t\t\t// on this poll, and if so, what they selected\n\t\t\tfor(c in poll.choices) {\n\t\t\t\tvar choice = poll.choices[c];\n\n\t\t\t\tfor(v in choice.votes) {\n\t\t\t\t\tvar vote = choice.votes[v];\n\t\t\t\t\ttotalVotes++;\n\n\t\t\t\t\tif(vote.ip === (req.header('x-forwarded-for') || req.ip)) {\n\t\t\t\t\t\tuserVoted = true;\n\t\t\t\t\t\tuserChoice = { _id: choice._id, text: choice.text };\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Attach info about user's past voting on this poll\n\t\t\tpoll.userVoted = userVoted;\n\t\t\tpoll.userChoice = userChoice;\n\n\t\t\tpoll.totalVotes = totalVotes;\n\n\t\t\tres.json(poll);\n\t\t} else {\n\t\t\tres.json({error:true});\n\t\t}\n\t});\n};\n\n// JSON API for creating a new poll\nexports.create = function(req, res) {\n\tvar reqBody = req.body,\n\t\t\t// Filter out choices with empty text\n\t\t\tchoices = reqBody.choices.filter(function(v) { return v.text != ''; }),\n\t\t\t// Build up poll object to save\n\t\t\tpollObj = {question: reqBody.question, choices: choices};\n\n\t// Create poll model from built up poll object\n\tvar poll = new Poll(pollObj);\n\n\t// Save poll to DB\n\tpoll.save(function(err, doc) {\n\t\tif(err || !doc) {\n\t\t\tthrow 'Error';\n\t\t} else {\n\t\t\tres.json(doc);\n\t\t}\n\t});\n};\n\nexports.vote = function(socket) {\n\tsocket.on('send:vote', function(data) {\n\t\tvar ip = socket.handshake.headers['x-forwarded-for'] || socket.handshake.address.address;\n\n\t\tPoll.findById(data.poll_id, function(err, poll) {\n\t\t\tvar choice = poll.choices.id(data.choice);\n\t\t\tchoice.votes.push({ ip: ip });\n\n\t\t\tpoll.save(function(err, doc) {\n\t\t\t\tvar theDoc = {\n\t\t\t\t\tquestion: doc.question, _id: doc._id, choices: doc.choices,\n\t\t\t\t\tuserVoted: false, totalVotes: 0\n\t\t\t\t};\n\n\t\t\t\t// Loop through poll choices to determine if user has voted\n\t\t\t\t// on this poll, and if so, what they selected\n\t\t\t\tfor(var i = 0, ln = doc.choices.length; i < ln; i++) {\n\t\t\t\t\tvar choice = doc.choices[i];\n\n\t\t\t\t\tfor(var j = 0, jLn = choice.votes.length; j < jLn; j++) {\n\t\t\t\t\t\tvar vote = choice.votes[j];\n\t\t\t\t\t\ttheDoc.totalVotes++;\n\t\t\t\t\t\ttheDoc.ip = ip;\n\n\t\t\t\t\t\tif(vote.ip === ip) {\n\t\t\t\t\t\t\ttheDoc.userVoted = true;\n\t\t\t\t\t\t\ttheDoc.userChoice = { _id: choice._id, text: choice.text };\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tsocket.emit('myvote', theDoc);\n\t\t\t\tsocket.broadcast.emit('vote', theDoc);\n\t\t\t});\n\t\t});\n\t});\n};\n","markerStore":{"nextMarkerId":1,"markersById":{"0":{"range":{"start":{"row":3,"column":15},"end":{"row":3,"column":15}},"properties":{"type":"selection","editorId":8,"goalScreenRange":null},"reversed":false,"tailed":true,"valid":true,"invalidate":"never","maintainHistory":true}},"version":2},"history":{"version":2,"nextCheckpointId":3,"undoStack":[{"type":"group-start","snapshot":{"0":{"range":[[0,0],[0,0]],"properties":{"type":"selection","editorId":8,"goalScreenRange":null},"reversed":false,"tailed":false,"valid":true,"invalidate":"never","maintainHistory":true}}},{"type":"change","content":{"oldRange":[[0,0],[0,0]],"newRange":[[0,0],[125,2]],"oldText":"","newText":"// Connect to MongoDB using Mongoose\nvar mongoose = require('mongoose');\nvar db;\nif (process.env.VCAP_SERVICES) {\n   var env = JSON.parse(process.env.VCAP_SERVICES);\n   db = mongoose.createConnection(env['mongodb-2.2'][0].credentials.url);\n} else {\n   db = mongoose.createConnection('localhost', 'pollsapp');\n}\n\n// Get Poll schema and model\nvar PollSchema = require('../models/Poll.js').PollSchema;\nvar Poll = db.model('polls', PollSchema);\n\n// Main application view\nexports.index = function(req, res) {\n\tres.render('index');\n};\n\n// JSON API for list of polls\nexports.list = function(req, res) {\n\t// Query Mongo for polls, just get back the question text\n\tPoll.find({}, 'question', function(error, polls) {\n\t\tres.json(polls);\n\t});\n};\n\n// JSON API for getting a single poll\nexports.poll = function(req, res) {\n\t// Poll ID comes in the URL\n\tvar pollId = req.params.id;\n\t\n\t// Find the poll by its ID, use lean as we won't be changing it\n\tPoll.findById(pollId, '', { lean: true }, function(err, poll) {\n\t\tif(poll) {\n\t\t\tvar userVoted = false,\n\t\t\t\t\tuserChoice,\n\t\t\t\t\ttotalVotes = 0;\n\n\t\t\t// Loop through poll choices to determine if user has voted\n\t\t\t// on this poll, and if so, what they selected\n\t\t\tfor(c in poll.choices) {\n\t\t\t\tvar choice = poll.choices[c]; \n\n\t\t\t\tfor(v in choice.votes) {\n\t\t\t\t\tvar vote = choice.votes[v];\n\t\t\t\t\ttotalVotes++;\n\n\t\t\t\t\tif(vote.ip === (req.header('x-forwarded-for') || req.ip)) {\n\t\t\t\t\t\tuserVoted = true;\n\t\t\t\t\t\tuserChoice = { _id: choice._id, text: choice.text };\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Attach info about user's past voting on this poll\n\t\t\tpoll.userVoted = userVoted;\n\t\t\tpoll.userChoice = userChoice;\n\n\t\t\tpoll.totalVotes = totalVotes;\n\t\t\n\t\t\tres.json(poll);\n\t\t} else {\n\t\t\tres.json({error:true});\n\t\t}\n\t});\n};\n\n// JSON API for creating a new poll\nexports.create = function(req, res) {\n\tvar reqBody = req.body,\n\t\t\t// Filter out choices with empty text\n\t\t\tchoices = reqBody.choices.filter(function(v) { return v.text != ''; }),\n\t\t\t// Build up poll object to save\n\t\t\tpollObj = {question: reqBody.question, choices: choices};\n\t\t\t\t\n\t// Create poll model from built up poll object\n\tvar poll = new Poll(pollObj);\n\t\n\t// Save poll to DB\n\tpoll.save(function(err, doc) {\n\t\tif(err || !doc) {\n\t\t\tthrow 'Error';\n\t\t} else {\n\t\t\tres.json(doc);\n\t\t}\t\t\n\t});\n};\n\nexports.vote = function(socket) {\n\tsocket.on('send:vote', function(data) {\n\t\tvar ip = socket.handshake.headers['x-forwarded-for'] || socket.handshake.address.address;\n\t\t\n\t\tPoll.findById(data.poll_id, function(err, poll) {\n\t\t\tvar choice = poll.choices.id(data.choice);\n\t\t\tchoice.votes.push({ ip: ip });\n\t\t\t\n\t\t\tpoll.save(function(err, doc) {\n\t\t\t\tvar theDoc = { \n\t\t\t\t\tquestion: doc.question, _id: doc._id, choices: doc.choices, \n\t\t\t\t\tuserVoted: false, totalVotes: 0 \n\t\t\t\t};\n\n\t\t\t\t// Loop through poll choices to determine if user has voted\n\t\t\t\t// on this poll, and if so, what they selected\n\t\t\t\tfor(var i = 0, ln = doc.choices.length; i < ln; i++) {\n\t\t\t\t\tvar choice = doc.choices[i]; \n\n\t\t\t\t\tfor(var j = 0, jLn = choice.votes.length; j < jLn; j++) {\n\t\t\t\t\t\tvar vote = choice.votes[j];\n\t\t\t\t\t\ttheDoc.totalVotes++;\n\t\t\t\t\t\ttheDoc.ip = ip;\n\n\t\t\t\t\t\tif(vote.ip === ip) {\n\t\t\t\t\t\t\ttheDoc.userVoted = true;\n\t\t\t\t\t\t\ttheDoc.userChoice = { _id: choice._id, text: choice.text };\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tsocket.emit('myvote', theDoc);\n\t\t\t\tsocket.broadcast.emit('vote', theDoc);\n\t\t\t});\t\t\t\n\t\t});\n\t});\n};"}},{"type":"change","content":{"oldRange":[[0,0],[0,0]],"newRange":[[0,0],[0,0]],"oldText":"","newText":""}},{"type":"group-end","snapshot":{"0":{"range":[[125,2],[125,2]],"properties":{"type":"selection","editorId":8,"goalScreenRange":null},"reversed":false,"tailed":false,"valid":true,"invalidate":"never","maintainHistory":true}}},{"type":"group-start","snapshot":{"0":{"range":[[3,15],[3,15]],"properties":{"type":"selection","editorId":8,"goalScreenRange":null},"reversed":false,"tailed":false,"valid":true,"invalidate":"never","maintainHistory":true}}},{"type":"change","content":{"oldRange":[[122,6],[122,9]],"newRange":[[122,6],[122,6]],"oldText":"\t\t\t","newText":""}},{"type":"change","content":{"oldRange":[[119,0],[119,4]],"newRange":[[119,0],[119,0]],"oldText":"\t\t\t\t","newText":""}},{"type":"change","content":{"oldRange":[[106,33],[106,34]],"newRange":[[106,33],[106,33]],"oldText":" ","newText":""}},{"type":"change","content":{"oldRange":[[100,36],[100,37]],"newRange":[[100,36],[100,36]],"oldText":" ","newText":""}},{"type":"change","content":{"oldRange":[[99,64],[99,65]],"newRange":[[99,64],[99,64]],"oldText":" ","newText":""}},{"type":"change","content":{"oldRange":[[98,18],[98,19]],"newRange":[[98,18],[98,18]],"oldText":" ","newText":""}},{"type":"change","content":{"oldRange":[[96,0],[96,3]],"newRange":[[96,0],[96,0]],"oldText":"\t\t\t","newText":""}},{"type":"change","content":{"oldRange":[[92,0],[92,2]],"newRange":[[92,0],[92,0]],"oldText":"\t\t","newText":""}},{"type":"change","content":{"oldRange":[[85,3],[85,5]],"newRange":[[85,3],[85,3]],"oldText":"\t\t","newText":""}},{"type":"change","content":{"oldRange":[[78,0],[78,1]],"newRange":[[78,0],[78,0]],"oldText":"\t","newText":""}},{"type":"change","content":{"oldRange":[[75,0],[75,4]],"newRange":[[75,0],[75,0]],"oldText":"\t\t\t\t","newText":""}},{"type":"change","content":{"oldRange":[[60,0],[60,2]],"newRange":[[60,0],[60,0]],"oldText":"\t\t","newText":""}},{"type":"change","content":{"oldRange":[[42,33],[42,34]],"newRange":[[42,33],[42,33]],"oldText":" ","newText":""}},{"type":"change","content":{"oldRange":[[31,0],[31,1]],"newRange":[[31,0],[31,0]],"oldText":"\t","newText":""}},{"type":"change","content":{"oldRange":[[125,2],[125,2]],"newRange":[[125,2],[126,0]],"oldText":"","newText":"\n"}},{"type":"group-end","snapshot":{"0":{"range":[[3,15],[3,15]],"properties":{"type":"selection","editorId":8,"goalScreenRange":null},"reversed":false,"tailed":true,"valid":true,"invalidate":"never","maintainHistory":true}}}],"redoStack":[]},"encoding":"utf8","filePath":"/Users/sanoy/code/savaho/routes/index.js","modifiedWhenLastPersisted":false,"digestWhenLastPersisted":"f16278a338978775fc76cad9978d5cb1269f762d","preferredLineEnding":"\n","deserializer":"TextBuffer","version":2}],"deserializer":"Project"},"workspace":{"paneContainer":{"root":{"id":3,"items":[{"id":8,"softTabs":true,"displayBuffer":{"id":9,"softWrapped":false,"scrollTop":0,"scrollLeft":0,"tokenizedBuffer":{"bufferPath":"/Users/sanoy/code/savaho/routes/index.js","largeFileMode":false,"deserializer":"TokenizedBuffer"},"largeFileMode":false,"deserializer":"DisplayBuffer"},"deserializer":"TextEditor"}],"activeItemURI":"/Users/sanoy/code/savaho/routes/index.js","focused":true,"flexScale":1,"deserializer":"Pane"},"activePaneId":3,"deserializer":"PaneContainer","version":1},"fullScreen":false,"packagesWithActiveGrammars":["language-javascript","language-hyperlink","language-todo"],"deserializer":"Workspace"},"packageStates":{"fuzzy-finder":{"/Users/sanoy/code/savaho/routes/index.js":1441290271654},"metrics":{"sessionLength":8964},"tabs":[{}],"tree-view":{"directoryExpansionStates":{"/Users/sanoy/code/savaho/routes":{"isExpanded":true,"entries":{}}},"selectedPath":"/Users/sanoy/code/savaho/routes/index.js","hasFocus":false,"attached":true,"scrollLeft":0,"scrollTop":0,"width":200}}}